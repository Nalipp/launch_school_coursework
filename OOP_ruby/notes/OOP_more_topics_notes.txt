Methods that take blocks
EXAMPLE
  def greeting(str)
    str
  end

  p greeting("hi") #valid
  p greeting("hi") { puts "world" } #valid but block has no effect

EXAMPLE
def greeting(str)
  yield
  str
end

p greeting('hi') #invlid LocalJumpError
p greeting('world') { puts "hi"} #valid

EXAMPLE
def greeting(str)
  yield if block_given?
  str
end

p greeting('hi') #valid
p greeting('world') { puts "hi"} #valid

1  # method implementation
2  def say(words)
3    yield if block_given?
4    puts "> " + words
5  end
6
7  # method invocation
8  say("hi there") do
9    system 'clear'
10 end
  #operations order [8, 2, 3, 9, 4, 5]


Yielding With An Argument

3.times do |num|
  puts num
end

what is 3?                   # The calling argument
what is times?               # The method being called
what is |num|?               # The argument parameter being passed to the block (num) is the block local variable.
                               Warning! if this block is not unique it can result in variable shadowing
what is do..end?             # The block

EXAMPLE
# method implementation
def increment(number)
  if block_given?
    yield(number + 1)
  else
    number + 1
  end
end

# method invocation
increment(5) do |num|
  puts num
end

#order of operations [11, 2, 3, 4, 11, 12, 13, 8]

EXAMPLE
def compare(str)
  puts "Before: #{str}"
  after = yield(str)
  puts "After: #{after}"
end

compare('hello') { |word| word.slice(1..2) } # el


Build a times method

def times(number)
  counter = 0
  while counter < number do
    yield(counter)
    counter += 1
  end
  number
end

times(5) do |num|
  puts num
end


Build an each method

def each(arr)
  count = 0
  while count < arr.length
    yield(arr[count])
    count += 1
  end
  arr
end

each([1, 2, 3, 4, 5]) do |num|
  puts num
end


Build a select method

def select(arr)
  counter = 0
  return_arr = []
  while counter < arr.length
    return_arr << arr[counter] if yield(arr[counter])
    counter += 1
  end
  return_arr
end


Build a reduce method

# p [1, 2, 3].reduce { |acc, num| acc + num } #6
# p [1, 2, 3].reduce { |acc, num| acc + num if num.odd? } #error
# p [1, 2, 3].reduce(10) { |acc, num| acc + num } #16

def reduce(arr, acc=0)
  counter = 0
  return_acc = acc
  while counter < arr.length
    return_acc += yield(arr)
    counter += 1
  end
  return_acc
end

array = [1, 2, 3, 4, 5]

# p reduce(array) { |acc, num| acc + num }                    # => 15
# p reduce(array, 10) { |acc, num| acc + num }                # => 25
# p reduce(array) { |acc, num| acc + num if num.odd? }        # => NoMethodError: undefined method `+' for nil:NilClass



Proc intro example

def call_me(some_code)
  some_code.call            # call will execute the "chunk of code" that passed in
end

name = "Robert"
chunk_of_code = Proc.new {puts "hi #{name}"}
name = "Vinny"

call_me(chunk_of_code)
