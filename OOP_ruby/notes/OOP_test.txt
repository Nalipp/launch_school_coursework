1. Explain the relationship between classes and objects. Use code to illustrate your explanation.

The class is like a mold where each instance of the class holds it's own state or data.
Objects use instance variables to hold data and are different from other objects of the same class.

Code example

```
class Country
  def initialize(name, language)
    @name = name
    @language = language
  end
end

spain = Country.new('Spain', 'Spanish')
germany = Country.new('Germany', 'German')
```

In this example Country is the class. Each country that is created has an instance variable for the country's name and language.
The class does not hold permanent data but is a template for creating objects that hold the data.
The new instances of the class 'spain' and 'data' are objects.



2. Explain what class inheritance is. Use code to illustrate your explanation.

Class inheritance is a way of structuring code in object oriented programing helps classes share code.
With class inheritance classes are able to inherit code from other classes that are higher up the inheritance hierarchy.

Code example

```
class StoreItem
  def initialize(name, price)
    @name = name
    @price = price
  end
end

class FoodItem < StoreItem
  def initialize(name, price, type)
    super(name, price)
    @type = type
  end
end

p banana = FoodItem.new('banana', 2, 'fruit')
p wheaties = FoodItem.new('wheaties', 4, 'cereal')
```

In this example the FoodItem class inherits from StoreItem.
Class inheritance allow us to share the price and name instance variables throughout different classes.
If we decided to make SchoolSuplies class or Clothing class these classes could also inherit StoreItem instance variables and methods.


3. How does Ruby handle the problem of multiple inheritance? Explain how this modifies the method lookup chain. Use code to illustrate your explanation.

Ruby only allows you to subclass from one class. Instead it allows for unlimited mixins of modules.
A module is encapsulated code that can be re-used by different classes.

Code example

```
module PerishableItem
  attr_accessor :shelf_life
end

class StoreItem
  def initialize(name, price)
    @name = name
    @price = price
  end
end

class FoodItem < StoreItem
  include PerishableItem

  def initialize(name, price, type)
    super(name, price)
    @type = type
  end
end

banana = FoodItem.new('banana', 2, 'fruit')
banana.shelf_life = '8 days'
wheaties = FoodItem.new('wheaties', 4, 'cereal')
wheaties.shelf_life = '40 days'
```
Food items now includes the PerishableItem module followed by the StoreItem class, Object, Kernel, and BasicObject classes.
When adding in a module all classes in the inheritance chain below the class containing the module will have access to the module.


4. What's the difference between a class and a module?

  Ruby doesn't allow multiple inheritance in classes but does allow unlimited inheritance from modules.
  When using classes it is common to use 'is-a' relationships where modules are better for 'has-a' relationships.
  Modules are also more commonly used for organizing code through name spacing and grouping common code together.
  One other key attribute is that Modules can not be instantiated.


5. What's the whole point of Object Oriented Programming? Pros and cons of OOP?
  Pros
  OOP is a way to keep code organized and scaleable. It allows programers to re-use code and encapsulate logic.
  Object orient programing makes it easer to keep code dry.
  Changes can be made up the code hierarchy that affect code below it automatically.

  Cons
  If the code is not well organized writing code can have unintended consequences.
  When coding a simple project there may be too much focus on extendability creating a lot of unnecessary code.

6. What does the phrase "OO Design" mean?
  Object oriented design is a way of planning out your code in advance.
  When thinking out OO Design you are forced to think about things like encapsulating logic, protecting data and inheritance instead of just writing code and then trying to piece it together later.

7. Explain why the last line in the below code outputs "bob". What are two possible ways to fix the change_info method so that it executes correctly?

  We can fix the code by adding '@', or '.self' to name in the change_info method.
  The reason bob.name still returns 'bob' is because when we set the new_name variable to name inside the method scope, Ruby thinks we are instantiating a new variable specific to the instance method scope.
  Calling 'self' or '@' inside an instance method is required for setter methods.

8. Use the Person class below, and create a class method called total_people, and have it return the total number of Person objects created.

```
class Person
  @@total_people = 0

  def initialize(name, weight, height)
    @name = name
    @weight = weight
    @height = height
    @@total_people += 1
  end

  def self.total_people
    @@total_people
  end
end

bob = Person.new('bob', 185, 70)
Person.total_people
```

9. Take the answer from the question above, and add a getter/setter for name, weight and height.

```
class Person
  attr_accessor :weight, :height

  @@total_people = 0

  def initialize(name, weight, height)
    @name = name
    @weight = weight
    @height = height
    @@total_people += 1
  end

  def self.total_people
    @@total_people
  end
end
```

10. Continuing on from the answer in the previous question, add a change_info(name, weight, height) instance method that can modify the object's 3 attributes all at once. Use the setter methods (as opposed to referencing the instance variables directly).

```
class Person
  attr_accessor :name, :weight, :height

  @@total_people = 0

  def initialize(name, weight, height)
    @name = name
    @weight = weight
    @height = height
    @@total_people += 1
  end

  def change_info(name, weight, height)
    self.name = name
    self.weight = weight
    self.height = height
  end

  def self.total_people
    @@total_people
  end
end

bob.change_info('bill', 190, 72)
```

11. Looking at the final code of the previous question, describe why self can be used both to define a class method and invoke an instance method. Explain how self works here.

  When we defined self.total_people we were defining a class method that returns the class instance @@total_people.
  We use class methods for referencing variables that are related to the entire class.
  When self is called inside an instance method it is referencing the object that called the method or calling the state of an individual object.
  Inside an instance method self is used as a setter method and communicates to Ruby not to instantiate a new variable but to set the instance variables of the object.


12. This exercise will ask that you come up with a class design for a fake "Employee Management Application".

```
class Employee
  attr_reader :name, :serial_number, :office

  def initialize(name, serial_number)
    @name = name
    @serial_number = serial_number
  end
end

class UpperManagment < Employee
  attr_reader :vacation, :prefix
end

class Executive < UpperManagment
  def initialize(name, serial_number)
    super(name, serial_number)
    @vacation = 20
    @prefix = 'Exe'
    @office = 'corner office'
  end
end

class Manager < UpperManagment
  def initialize(name, serial_number)
    super(name, serial_number)
    @vacation = 14
    @prefix = 'Mgr'
    @office = 'private_office'
  end
end

class RegularEmployee < Employee
  attr_reader :vacation

  def initialize(name, serial_number)
    super(name, serial_number)
    @vacation = 10
    @office = 'cubicle'
  end
end

class PartTime < Employee
  def initialize(name, serial_number)
    super(name, serial_number)
    @office = 'open workspace'
  end
end
```

Blocks
1. Explain what a closure is, and why do we say that it's at the core of understanding local variable scope?
  A closure is an unnamed chunk of code that can be used throughout a program and are useful for being passed into methods.
  Closures allow you to run custom blocks of code inside of the local variable scope of a method.

2. Explain the 2 major use cases for implementing a method that can take a block. Use code to illustrate your explanation.

  Writing a method that accepts a closure allows us to pass unique code to a method after it has been created.
  Closures are what allows us to pass code into methods like each or map and iterate over them according to their pre-defined methods.

  def each(arr)
    counter = 0
    while counter < arr.size
      yield(arr[counter])
      counter += 1
    end
    arr
  end

  each(['hi','how','are','you']) { |num| puts num}

=> hi
how
are
you

This code would not be as useful without being able to pass in a custom block. When we yield (arr[counter]) we are yielding the return value of the closure.
Other examples of methods where yielding a block is useful include map, each, select, reject and the times method.
Being able to pass in customized chunks of code is what makes these methods valuable.

Testing

What's the difference between MiniTest and RSpec?
MiniTest uses plain ruby but can do all of the things RSpec can. RSpec is a domain specific language "DSL" and is popular because it uses more natural sounding language.

Explain what assert_equal does. How does it test for equality?
assert_equal is used in testing to check for that the outcome is equal to what is expected.
When writing tests if you create an instance of a class and want to check the outcome you could use assert_equal.

```
def setup
  'kitty' = Cat.new('kitty')
end

def test_wheels
  assert_equal(kitty.name, 'kitty')
end
```

assert_equal allows you to pass in two parameters and check that they are equal.
